<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rate Limiter - Smart API Request Management - StackTrackr Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #495057 0%, #6c757d 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header .subtitle {
            font-size: 1.1em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .header .meta {
            font-size: 0.9em;
            opacity: 0.7;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav-bar {
            background: #f8f9fa;
            padding: 15px 30px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-link {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .content {
            padding: 40px;
            max-width: none;
        }

        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .content h1 { font-size: 2.2em; border-bottom: 3px solid #007acc; padding-bottom: 10px; }
        .content h2 { font-size: 1.8em; color: #007acc; }
        .content h3 { font-size: 1.4em; color: #495057; }
        .content h4 { font-size: 1.2em; color: #6c757d; }

        .content p {
            margin-bottom: 16px;
            line-height: 1.7;
            color: #444;
        }

        .content ul, .content ol {
            margin-bottom: 16px;
            padding-left: 25px;
        }

        .content li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .content blockquote {
            border-left: 4px solid #007acc;
            background: #f8f9fa;
            margin: 20px 0;
            padding: 15px 20px;
            border-radius: 0 6px 6px 0;
        }

        .content code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        .content pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .content pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .content th, .content td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e1e4e8;
        }

        .content th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .content tr:hover {
            background: #f8f9fa;
        }

        .content a {
            color: #007acc;
            text-decoration: none;
            font-weight: 500;
        }

        .content a:hover {
            color: #0056b3;
            text-decoration: underline;
        }

        .footer {
            background: #f8f9fa;
            padding: 20px 30px;
            border-top: 1px solid #e1e4e8;
            text-align: center;
            color: #6c757d;
            font-size: 0.9em;
        }

        .doc-meta {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #007acc;
        }

        .doc-meta h3 {
            color: #007acc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .meta-item {
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }

        .meta-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }

        .meta-value {
            color: #6c757d;
            font-size: 0.9em;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .content { padding: 20px; }
            .header { padding: 20px; }
            .nav-bar { padding: 15px 20px; }
            .nav-links { justify-content: center; }
            .header .meta { flex-direction: column; gap: 10px; }
        }

        /* Category-specific colors */
        .color-vision { --primary: #9c27b0; --secondary: #7b1fa2; }
        .color-roadmap { --primary: #007acc; --secondary: #0056b3; }
        .color-engine { --primary: #2c3e50; --secondary: #34495e; }
        .color-agent { --primary: #28a745; --secondary: #198754; }
        .color-brain { --primary: #6f42c1; --secondary: #495057; }
        .color-docker { --primary: #0db7ed; --secondary: #086dd7; }
        .color-mobile { --primary: #fd7e14; --secondary: #dc3545; }
        .color-protocol { --primary: #20c997; --secondary: #198754; }
        .color-scribe { --primary: #17a2b8; --secondary: #138496; }
        .color-groq { --primary: #ffc107; --secondary: #e0a800; }
        .color-task { --primary: #dc3545; --secondary: #c82333; }
        .color-cleanup { --primary: #6c757d; --secondary: #5a6268; }
        .color-quickstart { --primary: #28a745; --secondary: #198754; }
        .color-patch { --primary: #ff6b35; --secondary: #e55a32; }
        .color-rengine { --primary: #8b5cf6; --secondary: #7c3aed; }
        .color-default { --primary: #495057; --secondary: #6c757d; }
    </style>
</head>
<body class="color-default">
    <div class="container">
        <header class="header">
            <div class="header-icon">üìÑ</div>
            <h1>Rate Limiter - Smart API Request Management</h1>
            <div class="subtitle">Documentation</div>
            <div class="meta">
                <span>üìÅ rate-limiter.md</span>
                <span>üìÖ 2025-08-20</span>
                <span>üìä 10KB</span>
            </div>
        </header>

        <nav class="nav-bar">
            <div class="nav-links">
                <a href="../index.html" class="nav-link">üè† Documentation Home</a>
                <a href="../developmentstatus.html" class="nav-link">üìä Development Status</a>
                <a href="../generated/rate-limiter.md" class="nav-link">üìù View Source MD</a>
                <a href="../json/rate-limiter.json" class="nav-link">üîß JSON Data</a>
            </div>
        </nav>

        <main class="content">
            <h1 id="rate-limiter---smart-api-request-management">Rate Limiter - Smart API Request Management</h1>
<h2 id="purpose--overview">Purpose &amp; Overview</h2>
<p>The <code>rate-limiter.js</code> script is a powerful tool for managing API requests and preventing rate limit issues. It provides an implementation of a rate limiter that automatically handles:</p>
<ul>
<li><strong>Auto Rate Limiting</strong>: Tracks request history and enforces rate limits based on configurable thresholds.</li>
<li><strong>Exponential Backoff</strong>: Applies an exponential backoff strategy to retry failed requests, with configurable retry attempts and delay.</li>
<li><strong>Request Queuing</strong>: Queues requests and processes them asynchronously, ensuring efficient usage of available rate limit.</li>
<li><strong>Persistent State</strong>: Saves request history to a local file, allowing the rate limiter to resume operation after restarts.</li>
</ul>
<p>This script is designed to be used as a reusable module in larger applications that need to make frequent API requests while avoiding rate limit problems.</p>
<h2 id="technical-architecture">Technical Architecture</h2>
<p>The <code>RateLimiter</code> class is the core component of this script. It manages the following key elements:</p>
<ol>
<li><strong>Request History Tracking</strong>: The <code>requestHistory</code> array stores information about past requests, including success/failure status and timestamps.</li>
<li><strong>Request Queue</strong>: The <code>queue</code> array holds pending requests that are processed asynchronously.</li>
<li><strong>Retry Tracking</strong>: The <code>retryCount</code> map keeps track of the number of retry attempts for each request.</li>
<li><strong>Persistent State</strong>: The <code>loadState()</code> and <code>saveState()</code> methods handle loading and saving the rate limiter&#39;s state to a local JSON file.</li>
<li><strong>Cleanup and Maintenance</strong>: The <code>cleanupHistory()</code> method periodically removes old requests from the history to keep the data manageable.</li>
<li><strong>Rate Limit Handling</strong>: The <code>getCurrentLimits()</code> and <code>calculateWaitTime()</code> methods determine the current rate limit status and the appropriate delay before making the next request.</li>
<li><strong>Request Execution</strong>: The <code>makeRequest()</code>, <code>executeRequest()</code>, and <code>handleRequestError()</code> methods handle the actual execution of API requests, including retries and error handling.</li>
</ol>
<p>The overall data flow is as follows:</p>
<ol>
<li>The user calls the <code>makeRequest()</code> method, passing in a request function.</li>
<li>The request is added to the <code>queue</code> and processed asynchronously by the <code>processQueue()</code> method.</li>
<li>The <code>processQueue()</code> method checks the current rate limit status and either executes the request or delays the processing until the rate limit allows.</li>
<li>If a request fails, the <code>handleRequestError()</code> method determines if it&#39;s retryable and schedules a retry if necessary.</li>
<li>Successful and failed requests are recorded in the <code>requestHistory</code>.</li>
<li>The <code>saveState()</code> method is called periodically to persist the current state of the rate limiter.</li>
</ol>
<h2 id="dependencies">Dependencies</h2>
<p>This script imports the following dependencies:</p>
<ul>
<li><code>fs-extra</code>: Provides an enhanced file system API with additional functionality.</li>
<li><code>path</code>: Handles file paths and directory operations.</li>
</ul>
<h2 id="key-functionsclasses">Key Functions/Classes</h2>
<h3 id="ratelimiter-class"><code>RateLimiter</code> Class</h3>
<p>The <code>RateLimiter</code> class is the main implementation of the rate limiter functionality.</p>
<p><strong>Constructor</strong>:</p>
<ul>
<li><code>options</code> (optional): An object with configuration options for the rate limiter.<ul>
<li><code>name</code> (string): The name of the rate limiter instance.</li>
<li><code>maxRequestsPerMinute</code> (number): The maximum number of requests per minute.</li>
<li><code>maxRequestsPerHour</code> (number): The maximum number of requests per hour.</li>
<li><code>maxRetries</code> (number): The maximum number of retries for a failed request.</li>
<li><code>baseDelay</code> (number): The base delay (in milliseconds) for exponential backoff.</li>
<li><code>maxDelay</code> (number): The maximum delay (in milliseconds) for exponential backoff.</li>
</ul>
</li>
</ul>
<p><strong>Methods</strong>:</p>
<ul>
<li><code>loadState()</code>: Loads the rate limiter&#39;s persistent state from a local JSON file.</li>
<li><code>saveState()</code>: Saves the rate limiter&#39;s current state to a local JSON file.</li>
<li><code>cleanupHistory()</code>: Removes old requests from the request history and retry count.</li>
<li><code>getCurrentLimits()</code>: Calculates the current rate limit status based on the request history.</li>
<li><code>calculateDelay(retryAttempt, isRateLimit)</code>: Calculates the delay for a retry attempt, using exponential backoff or a longer delay for rate limit errors.</li>
<li><code>makeRequest(requestFn, requestId)</code>: Adds a new request to the queue and returns a Promise that resolves with the request&#39;s result.</li>
<li><code>processQueue()</code>: Processes the request queue, executing requests and handling rate limit issues.</li>
<li><code>executeRequest(request)</code>: Executes a request and handles the result or any errors.</li>
<li><code>handleRequestError(request, error)</code>: Handles errors that occur during request execution, retrying if possible.</li>
<li><code>isRateLimitError(error)</code>: Determines if an error is a rate limit error based on the response status and message.</li>
<li><code>isRetryableError(error)</code>: Determines if an error is retryable based on the response status.</li>
<li><code>sleep(ms)</code>: Implements a simple Promise-based delay.</li>
<li><code>getStats()</code>: Returns a summary of the rate limiter&#39;s current state.</li>
<li><code>shutdown()</code>: Saves the current state and shuts down the rate limiter.</li>
</ul>
<h2 id="usage-examples">Usage Examples</h2>
<p>To use the <code>RateLimiter</code> in your application, you can import it and create a new instance with the desired configuration:</p>
<pre><code class="language-javascript"><pre><code class="language-javascript">import RateLimiter from './rate-limiter.js';

const limiter = new RateLimiter({
  name: 'my-api',
  maxRequestsPerMinute: 30,
  maxRequestsPerHour: 1000,
  maxRetries: 5,
  baseDelay: 500,
  maxDelay: 30000
});

async function fetchData() {
  try {
    const result = await limiter.makeRequest(async () => {
      // Your API request logic here
      const response = await fetch('https://api.example.com/data');
      return await response.json();
    });
    console.log(result);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}

fetchData();</code></pre>
</code></pre>
<p>In this example, we create a new <code>RateLimiter</code> instance with a specific configuration, and then use the <code>makeRequest()</code> method to execute an API request. The rate limiter will automatically handle rate limiting, retries, and queueing of the request.</p>
<h2 id="configuration">Configuration</h2>
<p>The <code>RateLimiter</code> class accepts the following configuration options in the constructor:</p>
<table>
<thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>name</code></td>
<td><code>string</code></td>
<td><code>&#39;default&#39;</code></td>
<td>The name of the rate limiter instance.</td>
</tr>
<tr>
<td><code>maxRequestsPerMinute</code></td>
<td><code>number</code></td>
<td><code>15</code></td>
<td>The maximum number of requests per minute.</td>
</tr>
<tr>
<td><code>maxRequestsPerHour</code></td>
<td><code>number</code></td>
<td><code>500</code></td>
<td>The maximum number of requests per hour.</td>
</tr>
<tr>
<td><code>maxRetries</code></td>
<td><code>number</code></td>
<td><code>3</code></td>
<td>The maximum number of retries for a failed request.</td>
</tr>
<tr>
<td><code>baseDelay</code></td>
<td><code>number</code></td>
<td><code>1000</code></td>
<td>The base delay (in milliseconds) for exponential backoff.</td>
</tr>
<tr>
<td><code>maxDelay</code></td>
<td><code>number</code></td>
<td><code>60000</code></td>
<td>The maximum delay (in milliseconds) for exponential backoff.</td>
</tr>
</tbody></table>
<h2 id="error-handling">Error Handling</h2>
<p>The <code>RateLimiter</code> class handles errors in the following ways:</p>
<ol>
<li><strong>Rate Limit Errors</strong>: If a request fails due to a rate limit error (e.g., HTTP status 429 or 503), the rate limiter will wait for the appropriate amount of time before retrying the request.</li>
<li><strong>Retryable Errors</strong>: If a request fails due to a retryable error (e.g., a server-side error), the rate limiter will retry the request up to the <code>maxRetries</code> limit, using an exponential backoff strategy.</li>
<li><strong>Non-Retryable Errors</strong>: If a request fails due to a non-retryable error (e.g., a client-side error), the rate limiter will not retry the request and will instead reject the Promise returned by <code>makeRequest()</code>.</li>
</ol>
<p>The <code>isRateLimitError()</code> and <code>isRetryableError()</code> methods determine the type of error and the appropriate handling strategy.</p>
<h2 id="integration">Integration</h2>
<p>The <code>rate-limiter.js</code> script is designed to be easily integrated into larger applications that need to make frequent API requests. By importing the <code>RateLimiter</code> class and creating an instance with the desired configuration, you can seamlessly add rate limiting and error handling capabilities to your API request logic.</p>
<p>The rate limiter&#39;s persistent state is saved to a local JSON file, allowing it to resume operation after application restarts or server reboots. This ensures that the rate limiting and request history is maintained across sessions, providing a more robust and reliable API request management system.</p>
<h2 id="development-notes">Development Notes</h2>
<ol>
<li><p><strong>Persistent State</strong>: The rate limiter&#39;s state is saved to a local JSON file to ensure that the request history and retry counts are preserved across application restarts. This allows the rate limiter to resume operation without losing important context.</p>
</li>
<li><p><strong>Cleanup and Maintenance</strong>: The <code>cleanupHistory()</code> method periodically removes old requests from the request history to keep the data manageable. This helps maintain the performance of the rate limiter over time, as the history can grow quite large for applications making a large number of requests.</p>
</li>
<li><p><strong>Exponential Backoff</strong>: The rate limiter uses an exponential backoff strategy for retrying failed requests. This helps prevent overwhelming the API with too many retry attempts in a short period of time, which could potentially lead to further rate limit issues.</p>
</li>
<li><p><strong>Jitter</strong>: When calculating the delay for a retry attempt, a small amount of random jitter is added to the delay. This helps prevent the &quot;thundering herd&quot; problem, where multiple instances of the application try to retry at the same time, potentially causing additional rate limit issues.</p>
</li>
<li><p><strong>Asynchronous Processing</strong>: The rate limiter processes requests asynchronously, using the <code>processQueue()</code> method to execute requests as rate limit conditions allow. This ensures that the application can continue to add requests to the queue without blocking the main execution thread.</p>
</li>
<li><p><strong>Shutdown Handling</strong>: The <code>shutdown()</code> method is provided to allow the rate limiter to be gracefully shut down, saving the current state before the application exits. This helps ensure that the rate limiter&#39;s state is preserved, even in the event of a sudden application shutdown.</p>
</li>
</ol>

        </main>

        <footer class="footer">
            <p>Generated from <strong>rate-limiter.md</strong> ‚Ä¢ StackTrackr Documentation System ‚Ä¢ Last updated: 2025-08-20</p>
        </footer>
    </div>
</body>
</html>