<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Memory Search Index - Proof of Concept - StackTrackr Documentation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #495057 0%, #6c757d 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.9;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header .subtitle {
            font-size: 1.1em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .header .meta {
            font-size: 0.9em;
            opacity: 0.7;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav-bar {
            background: #f8f9fa;
            padding: 15px 30px;
            border-bottom: 1px solid #e1e4e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .nav-links {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .nav-link {
            padding: 8px 16px;
            background: #007acc;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .content {
            padding: 40px;
            max-width: none;
        }

        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .content h1 { font-size: 2.2em; border-bottom: 3px solid #007acc; padding-bottom: 10px; }
        .content h2 { font-size: 1.8em; color: #007acc; }
        .content h3 { font-size: 1.4em; color: #495057; }
        .content h4 { font-size: 1.2em; color: #6c757d; }

        .content p {
            margin-bottom: 16px;
            line-height: 1.7;
            color: #444;
        }

        .content ul, .content ol {
            margin-bottom: 16px;
            padding-left: 25px;
        }

        .content li {
            margin-bottom: 8px;
            line-height: 1.6;
        }

        .content blockquote {
            border-left: 4px solid #007acc;
            background: #f8f9fa;
            margin: 20px 0;
            padding: 15px 20px;
            border-radius: 0 6px 6px 0;
        }

        .content code {
            background: #f8f9fa;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            color: #e83e8c;
        }

        .content pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .content pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        .content table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .content th, .content td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #e1e4e8;
        }

        .content th {
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .content tr:hover {
            background: #f8f9fa;
        }

        .content a {
            color: #007acc;
            text-decoration: none;
            font-weight: 500;
        }

        .content a:hover {
            color: #0056b3;
            text-decoration: underline;
        }

        .footer {
            background: #f8f9fa;
            padding: 20px 30px;
            border-top: 1px solid #e1e4e8;
            text-align: center;
            color: #6c757d;
            font-size: 0.9em;
        }

        .doc-meta {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #007acc;
        }

        .doc-meta h3 {
            color: #007acc;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .meta-item {
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
        }

        .meta-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9em;
        }

        .meta-value {
            color: #6c757d;
            font-size: 0.9em;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .content { padding: 20px; }
            .header { padding: 20px; }
            .nav-bar { padding: 15px 20px; }
            .nav-links { justify-content: center; }
            .header .meta { flex-direction: column; gap: 10px; }
        }

        /* Category-specific colors */
        .color-vision { --primary: #9c27b0; --secondary: #7b1fa2; }
        .color-roadmap { --primary: #007acc; --secondary: #0056b3; }
        .color-engine { --primary: #2c3e50; --secondary: #34495e; }
        .color-agent { --primary: #28a745; --secondary: #198754; }
        .color-brain { --primary: #6f42c1; --secondary: #495057; }
        .color-docker { --primary: #0db7ed; --secondary: #086dd7; }
        .color-mobile { --primary: #fd7e14; --secondary: #dc3545; }
        .color-protocol { --primary: #20c997; --secondary: #198754; }
        .color-scribe { --primary: #17a2b8; --secondary: #138496; }
        .color-groq { --primary: #ffc107; --secondary: #e0a800; }
        .color-task { --primary: #dc3545; --secondary: #c82333; }
        .color-cleanup { --primary: #6c757d; --secondary: #5a6268; }
        .color-quickstart { --primary: #28a745; --secondary: #198754; }
        .color-patch { --primary: #ff6b35; --secondary: #e55a32; }
        .color-rengine { --primary: #8b5cf6; --secondary: #7c3aed; }
        .color-default { --primary: #495057; --secondary: #6c757d; }
    </style>
</head>
<body class="color-default">
    <div class="container">
        <header class="header">
            <div class="header-icon">üìÑ</div>
            <h1>Quick Memory Search Index - Proof of Concept</h1>
            <div class="subtitle">Documentation</div>
            <div class="meta">
                <span>üìÅ quick-memory-search.md</span>
                <span>üìÖ 2025-08-20</span>
                <span>üìä 7KB</span>
            </div>
        </header>

        <nav class="nav-bar">
            <div class="nav-links">
                <a href="../index.html" class="nav-link">üè† Documentation Home</a>
                <a href="../developmentstatus.html" class="nav-link">üìä Development Status</a>
                <a href="../rAgents/rEngine/quick-memory-search.md" class="nav-link">üìù View Source MD</a>
                <a href="../json/quick-memory-search.json" class="nav-link">üîß JSON Data</a>
            </div>
        </nav>

        <main class="content">
            <h1 id="quick-memory-search-index---proof-of-concept">Quick Memory Search Index - Proof of Concept</h1>
<h2 id="purpose--overview">Purpose &amp; Overview</h2>
<p>The <code>quick-memory-search.js</code> script provides a fast in-memory search capability for the StackTrackr agent memory, without requiring a database migration or complex setup. It allows users to quickly search through the agent&#39;s memory data and retrieve relevant information, without the need for a dedicated search infrastructure.</p>
<h2 id="technical-architecture">Technical Architecture</h2>
<p>The script is built around the <code>QuickMemorySearch</code> class, which is responsible for the following key components:</p>
<ol>
<li><p><strong>Indexing</strong>: The class builds an in-memory index of the agent&#39;s entities, including their metadata, keywords, relationships, and searchable text. This index is constructed from the <code>memory.json</code> file and any additional context files (e.g., <code>agents.json</code>, <code>tasks.json</code>, <code>decisions.json</code>).</p>
</li>
<li><p><strong>Searching</strong>: The <code>search()</code> method allows users to query the index and retrieve relevant entities based on various strategies, such as exact keyword matches, partial keyword matches, and full-text search.</p>
</li>
<li><p><strong>Relationship Traversal</strong>: The <code>findRelated()</code> method allows users to discover related entities by traversing the relationship index, up to a specified depth.</p>
</li>
<li><p><strong>Utility Methods</strong>: The class also provides additional methods for retrieving entity details, suggesting search terms, and accessing search statistics.</p>
</li>
</ol>
<p>The overall data flow is as follows:</p>
<ol>
<li>The <code>QuickMemorySearch</code> instance is initialized, loading the agent&#39;s memory data and building the search index.</li>
<li>Users can then invoke the <code>search()</code> method with a query string to find relevant entities.</li>
<li>The search results include the matched entities, their relevance scores, and a relevance explanation.</li>
<li>Optionally, users can further explore the relationships between entities using the <code>findRelated()</code> method.</li>
</ol>
<h2 id="dependencies">Dependencies</h2>
<p>The script depends on the following Node.js built-in modules:</p>
<ul>
<li><code>fs/promises</code>: For asynchronous file I/O operations.</li>
<li><code>path</code>: For working with file paths.</li>
</ul>
<h2 id="key-functionsclasses">Key Functions/Classes</h2>
<h3 id="quickmemorysearch-class"><code>QuickMemorySearch</code> Class</h3>
<p>This is the main class responsible for managing the search index and providing search-related functionality.</p>
<h4 id="constructor">Constructor</h4>
<pre><code class="language-typescript"><pre><code class="language-typescript">constructor(agentsPath: string = './rAgents')</code></pre>
</code></pre>
<ul>
<li><strong>Parameters</strong>:<ul>
<li><code>agentsPath</code> (optional, default: <code>&#39;./rAgents&#39;</code>): The path to the directory containing the agent&#39;s memory and context files.</li>
</ul>
</li>
</ul>
<h4 id="methods">Methods</h4>
<ol>
<li><code>initialize()</code>: Initializes the search index by loading the agent&#39;s memory data and building the index structures.</li>
<li><code>search(query: string, options?: SearchOptions)</code>: Performs a search query against the index and returns the results.</li>
<li><code>findRelated(entityId: string, maxDepth?: number, visited?: Set&lt;string&gt;)</code>: Finds related entities by traversing the relationship index.</li>
<li><code>getEntity(entityId: string)</code>: Retrieves an entity by its ID.</li>
<li><code>searchByType(entityType: string)</code>: Retrieves all entities of a specific type.</li>
<li><code>suggestTerms(partial: string, maxSuggestions?: number)</code>: Suggests search terms based on the indexed keywords.</li>
<li><code>getStats()</code>: Retrieves various statistics about the search index.</li>
</ol>
<h4 id="search-options">Search Options</h4>
<p>The <code>search()</code> method accepts an optional <code>SearchOptions</code> object with the following properties:</p>
<pre><code class="language-typescript"><pre><code class="language-typescript">interface SearchOptions {
  maxResults?: number;
  includeScore?: boolean;
  entityTypes?: string | string[];
  minScore?: number;
}</code></pre>
</code></pre>
<ul>
<li><code>maxResults</code>: The maximum number of results to return (default: 10).</li>
<li><code>includeScore</code>: Whether to include the relevance score and explanation in the results (default: true).</li>
<li><code>entityTypes</code>: The entity types to include in the search results (default: all types).</li>
<li><code>minScore</code>: The minimum relevance score for a result to be included (default: 0.1).</li>
</ul>
<h2 id="usage-examples">Usage Examples</h2>
<p>Here are some examples of how to use the <code>QuickMemorySearch</code> class:</p>
<pre><code class="language-javascript"><pre><code class="language-javascript">// Initialize the search index
const searcher = new QuickMemorySearch();
await searcher.initialize();

// Perform a search
const results = searcher.search('docker permission issues', { maxResults: 3 });
console.log(results.results);

// Find related entities
const relatedEntities = searcher.findRelated('entity_id_123', 2);
console.log(relatedEntities);

// Get entity details
const entity = searcher.getEntity('entity_id_456');
console.log(entity);

// Search by entity type
const typeResults = searcher.searchByType('task');
console.log(typeResults);

// Suggest search terms
const suggestions = searcher.suggestTerms('server');
console.log(suggestions);

// Get search index statistics
const stats = searcher.getStats();
console.log(stats);</code></pre>
</code></pre>
<h2 id="configuration">Configuration</h2>
<p>The <code>QuickMemorySearch</code> class accepts an optional <code>agentsPath</code> parameter in the constructor, which specifies the directory containing the agent&#39;s memory and context files. If not provided, it defaults to <code>&#39;./rAgents&#39;</code>.</p>
<h2 id="error-handling">Error Handling</h2>
<p>The <code>QuickMemorySearch</code> class handles errors that may occur during the initialization and search processes. If an error occurs, it will be logged to the console, and the error will be propagated up the call stack.</p>
<h2 id="integration">Integration</h2>
<p>The <code>quick-memory-search.js</code> script is designed to be used as a standalone component within the StackTrackr system. It can be integrated into other parts of the application that require fast in-memory search capabilities for the agent&#39;s memory data.</p>
<h2 id="development-notes">Development Notes</h2>
<ol>
<li><p><strong>Indexing Optimization</strong>: The current implementation builds the entire index in-memory during the initialization process. For larger datasets, this approach may not be scalable. Consideration should be given to implementing incremental indexing or on-demand loading strategies.</p>
</li>
<li><p><strong>Concurrency and Thread Safety</strong>: The current implementation is not designed to handle concurrent access to the search index. If multiple threads or processes are expected to use the <code>QuickMemorySearch</code> class, additional synchronization mechanisms may be required.</p>
</li>
<li><p><strong>Ranking and Relevance</strong>: The current relevance calculation is based on a simple heuristic. For more advanced use cases, the ranking algorithm may need to be refined to provide more accurate and contextual relevance scores.</p>
</li>
<li><p><strong>Extensibility</strong>: The class structure and methods can be extended to support additional features, such as custom scoring functions, advanced query parsing, or integration with external data sources.</p>
</li>
<li><p><strong>Performance Optimization</strong>: Depending on the size and complexity of the agent&#39;s memory data, further optimizations may be necessary to ensure efficient search performance, such as using more advanced data structures, caching techniques, or parallelization.</p>
</li>
<li><p><strong>Serialization and Persistence</strong>: The current implementation loads the index data from the file system during initialization. Consideration should be given to implementing serialization and persistence mechanisms to allow for faster startup times and easier deployment.</p>
</li>
</ol>

        </main>

        <footer class="footer">
            <p>Generated from <strong>quick-memory-search.md</strong> ‚Ä¢ StackTrackr Documentation System ‚Ä¢ Last updated: 2025-08-20</p>
        </footer>
    </div>
</body>
</html>