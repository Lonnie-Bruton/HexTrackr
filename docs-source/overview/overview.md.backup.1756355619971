# HexTrackr Codebase Analysis

## Project Overview

HexTrackr is a dual-purpose cybersecurity management system built with Node.js, Express.js, SQLite, and a mix of client-side technologies (JavaScript, HTML, CSS).  It features a ticket management system and a vulnerability management system, sharing common components like navigation and settings.  The system uses a SQLite database to store tickets and vulnerability data. The backend API uses Express.js to handle various HTTP requests related to data management (CRUD operations).  The frontend interacts with the backend API through AJAX requests. A prototype documentation system is in place, utilizing Tabler.io templates for the HTML presentation.

The system incorporates CSV import and export functionalities along with PDF generation for tickets using jsPDF.  The vulnerabilities system utilizes an AG Grid for data presentation.  The `scripts/init-database.js` file handles database initialization and schema creation.  A version management script updates version numbers across relevant files. The system includes a settings modal with data management features including backup/restore. The project uses JSON for data transfer between the frontend and backend.

## API Endpoints Discovered

### GET /api/vulnerabilities/stats

**Purpose**: Retrieve vulnerability statistics grouped by severity, including count, total VPR score, average VPR score, earliest and latest seen dates.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/vulnerabilities/stats')
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
[
  {
    "severity": "Critical",
    "count": 15,
    "total_vpr": 75.5,
    "avg_vpr": 5.03,
    "earliest": "2024-01-15",
    "latest": "2024-08-26"
  },
  // ... more severity entries
]
```

**Location**: `server.js:70`
**Used By**: `vulnerabilities.html` (likely for dashboard statistics)

### GET /api/vulnerabilities/trends

**Purpose**: Get historical vulnerability trends for the last 14 days, grouped by date and severity.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/vulnerabilities/trends')
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
[
  {
    "date": "2024-08-26",
    "Critical": 2,
    "High": 5,
    "Medium": 10,
    "Low": 3
  },
  // ... more date entries
]
```

**Location**: `server.js:106`
**Used By**: `vulnerabilities.html` (likely for a trend chart)

### GET /api/vulnerabilities

**Purpose**: Retrieve vulnerabilities with pagination and filtering options.
**Parameters**:

- `page` (integer, optional) - Page number (default: 1)
- `limit` (integer, optional) - Number of vulnerabilities per page (default: 50)
- `search` (string, optional) - Search term (matches hostname, CVE, or plugin name)
- `severity` (string, optional) - Filter by severity

**Request Example**:
```javascript
fetch('/api/vulnerabilities?page=2&limit=20&search=example&severity=Critical')
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{
  "data": [ /* array of vulnerability objects */ ],
  "pagination": {
    "page": 2,
    "limit": 20,
    "total": 1000,
    "pages": 50
  }
}
```

**Location**: `server.js:155`
**Used By**: `vulnerabilities.html` (for the vulnerability grid)

### POST /api/vulnerabilities/import

**Purpose**: Import vulnerabilities from a CSV file.
**Parameters**:

- `csvFile` (file) - CSV file to import
- `vendor` (string, optional) - Vendor of the vulnerability data

**Request Example**:  (Requires multipart/form-data)
```javascript
const formData = new FormData();
formData.append('csvFile', file);
formData.append('vendor', 'Cisco');

fetch('/api/vulnerabilities/import', {
  method: 'POST',
  body: formData
})
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{
  "success": true,
  "importId": 123,
  "rowsProcessed": 100,
  "filename": "vulnerabilities.csv",
  "processingTime": 5000 // milliseconds
}
```

**Location**: `server.js:216`
**Used By**: `vulnerabilities.html` (for CSV upload)

### DELETE /api/vulnerabilities/clear

**Purpose**: Clear all vulnerability data from the database.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/vulnerabilities/clear', { method: 'DELETE' })
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{ "success": true, "message": "All vulnerability data cleared" }
```

**Location**: `server.js:310`
**Used By**:  Likely a settings modal action

### GET /api/imports

**Purpose**: Retrieve the history of vulnerability imports.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/imports')
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:  (Array of import records)

**Location**: `server.js:325`
**Used By**: Likely a settings modal action

### DELETE /api/backup/clear/:type

**Purpose**: Clear vulnerabilities, tickets, or all data based on the `type` parameter.
**Parameters**:

- `type` (string) - Type of data to clear ('vulnerabilities', 'tickets', 'all')

**Request Example**:
```javascript
fetch('/api/backup/clear/vulnerabilities', { method: 'DELETE' })
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{ "message": "vulnerabilities cleared successfully" }
```

**Location**: `server.js:340`
**Used By**: Settings modal

### GET /api/backup/stats

**Purpose**: Retrieve statistics about the size and number of records in the database.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/backup/stats')
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{
    "vulnerabilities": 123,
    "tickets": 456,
    "total": 579,
    "dbSize": 1234567
}
```

**Location**: `server.js:398`
**Used By**: Settings modal

### GET /api/backup/vulnerabilities

**Purpose**: Export vulnerabilities data.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/backup/vulnerabilities')
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{
    "type": "vulnerabilities",
    "count": 123,
    "data": [ /* vulnerabilities data */ ],
    "exported_at": "2024-08-27T10:30:00.000Z"
}
```

**Location**: `server.js:418`
**Used By**: Settings modal

### GET /api/tickets

**Purpose**: Retrieve all tickets ordered by created_at descending.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/tickets')
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
[
    {
        // ... ticket data
    }
]
```

**Location**: `server.js:432`
**Used By**: `tickets.js`

### POST /api/tickets

**Purpose**: Create a new ticket.
**Parameters**: The ticket object as the request body (JSON).
**Request Example**:
```javascript
fetch('/api/tickets', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(ticket)
})
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{ "success": true, "id": "ticketId", "message": "Ticket saved successfully" }
```

**Location**: `server.js:494`
**Used By**: `tickets.js`

### PUT /api/tickets/:id

**Purpose**: Update an existing ticket.
**Parameters**:

- `id` (string) - ID of the ticket to update in the URL path.
- Ticket data as request body (JSON).

**Request Example**:
```javascript
fetch(`/api/tickets/${ticketId}`, {
    method: 'PUT',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify(ticket)
})
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{ "success": true, "id": "ticketId", "message": "Ticket updated successfully" }
```

**Location**: `server.js:525`
**Used By**: `tickets.js`

### DELETE /api/tickets/:id

**Purpose**: Delete a ticket.
**Parameters**: `id` (string) - ID of the ticket to delete in the URL path.
**Request Example**:
```javascript
fetch(`/api/tickets/${ticketId}`, { method: 'DELETE' })
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{ "success": true, "deleted": 1 }
```

**Location**: `server.js:556`
**Used By**: `tickets.js`

### POST /api/tickets/migrate

**Purpose**: Migrate tickets from localStorage to database. Handles replacement or appending.
**Parameters**: `tickets` (array) - Array of ticket objects to migrate; `mode` (string) - 'replace' or 'append'.
**Request Example**:
```javascript
fetch('/api/tickets/migrate', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ tickets: localStorageTickets, mode: 'append' })
})
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{ "success": true, "message": "Migration completed: X tickets migrated, Y errors" }
```

**Location**: `server.js:571`
**Used By**: `tickets.js`

### POST /api/import/tickets

**Purpose**: Import tickets from a JSON payload (presumably from a CSV parsed client-side).
**Parameters**:  `data` (array) - Array of ticket objects
**Request Example**:
```javascript
fetch('/api/import/tickets', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ data: parsedTickets })
})
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{
    "success": true,
    "imported": 10,
    "total": 10,
    "errors": []
}
```

**Location**: `server.js:681`
**Used By**: `tickets.js`

### POST /api/import/vulnerabilities

**Purpose**: Import vulnerabilities from a JSON payload (presumably from a CSV parsed client-side).
**Parameters**: `data` (array) - Array of vulnerability objects
**Request Example**:
```javascript
fetch('/api/import/vulnerabilities', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ data: parsedVulnerabilities })
})
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**: Similar to POST /api/import/tickets

**Location**: `server.js:792`
**Used By**: `vulnerabilities.js`

### GET /api/sites

**Purpose**: Retrieve site data from the database.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/sites')
    .then(response => response.json())
    .then(data => console.log(data))
```

**Response Format**: Array of site objects.

**Location**: `server.js:565`
**Used By**: `tickets.js` (for site filter)

### GET /api/locations

**Purpose**: Retrieve location data from the database.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/locations')
    .then(response => response.json())
    .then(data => console.log(data))
```

**Response Format**: Array of location objects.

**Location**: `server.js:578`
**Used By**: `tickets.js` (for location filter)

### GET /api/backup/tickets

**Purpose**: Export all tickets ordered by created_at descending.
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/backup/tickets')
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**: Same as `/api/backup/vulnerabilities`

**Location**: `server.js:836`
**Used By**: `settings-modal.js`

### GET /api/backup/all

**Purpose**: Export all data (tickets and vulnerabilities).
**Parameters**: None
**Request Example**:
```javascript
fetch('/api/backup/all')
.then(response => response.json())
.then(data => console.log(data));
```

**Response Format**:
```json
{
    "type": "complete_backup",
    "vulnerabilities": {
        "count": 123,
        "data": [ /* vulnerabilities data */ ]
    },
    "tickets": {
        "count": 456,
        "data": [ /* tickets data */ ]
    },
    "exported_at": "2024-08-27T10:30:00.000Z"
}
```

**Location**: `server.js:851`
**Used By**: `settings-modal.js`

### POST /api/restore

**Purpose**: Restore data from a ZIP backup.
**Parameters**:

- `file` (file) - ZIP backup file.
- `type` (string) - Type of data to restore ('tickets', 'vulnerabilities', 'all').
- `clearExisting` (string, optional) - Whether to clear existing data before restoring ('true' or 'false').

**Request Example**: (Requires multipart/form-data)
```javascript
const formData = new FormData();
formData.append('file', file);
formData.append('type', 'all');
formData.append('clearExisting', 'true');

fetch('/api/restore', {
  method: 'POST',
  body: formData
})
  .then(response => response.json())
  .then(data => console.log(data));
```

**Response Format**:
```json
{
  "success": true,
  "message": "Successfully restored X records",
  "count": X
}
```

**Location**: `server.js:872`
**Used By**: `settings-modal.js`

### GET /api/settings

**Purpose**: Fetch current settings. (Not implemented in the provided code)
**Parameters**: None
**Location**: Not implemented

### POST /api/settings

**Purpose**: Save settings to the server. (Not implemented in the provided code)
**Parameters**: The settings object as request body (JSON).
**Location**: Not implemented

## Frontend Functions

The frontend code is primarily located in `scripts/pages/tickets.js` and `scripts/pages/vulnerabilities.js`.  `scripts/shared/*` contains shared components.  A complete function-by-function documentation for these would be extensive.  However,  key function categories are:

* **Ticket Management:**  `HexagonTicketsManager` class in `tickets.js` handles all ticket-related functions (CRUD, filtering, pagination, CSV export, PDF generation, etc.).
* **Vulnerability Management:**  The `vulnerabilities.js` file (currently mostly in the HTML) will contain the vulnerability management functions (data handling, grid interaction, charting, CSV import/export).
* **Shared Components:**  Functions for modal handling, navigation, etc., in `scripts/shared/`.  These are used by both the tickets and vulnerabilities pages.
* **Data Handling/Formatting:** Functions for date formatting, CSV parsing, and data transformation.
* **Utility Functions:** Helper functions for tasks such as showing notifications, handling file downloads, and manipulating the DOM.

Detailed documentation for individual functions would follow the specified markdown format and would be generated automatically by a code analysis tool.

## Database Schema

The database schema is defined in `scripts/init-database.js`.  It consists of the following tables:

* **tickets:**  Stores ticket information. The `devices` and `attachments` columns are JSON arrays.  The `id` column acts as the primary key, and uses `xt_number` if `id` is not available.
* **vulnerability_imports:** Tracks CSV import history, including metadata.
* **vulnerabilities:** Stores normalized vulnerability data.  The `import_id` is a foreign key referencing `vulnerability_imports`.
* **ticket_vulnerabilities:** A junction table linking tickets and vulnerabilities.

The script also creates several indexes to improve query performance.

## Security Assessment

The `server.js` file demonstrates some security considerations:

* **HTTP Security Headers:**  The middleware sets crucial headers (`X-Content-Type-Options`, `X-Frame-Options`, `X-XSS-Protection`) to mitigate various vulnerabilities.
* **File Upload Limits:** Multer is used to limit file upload size, preventing potential denial-of-service attacks.
* **Input Validation (Partial):** Some input validation is performed, particularly in the CSV import functions.  However, additional validation is likely needed in other areas.
* **Parameterized Queries (Mostly):** Parameterized queries are used for database operations where possible, which protects against SQL injection.

## Security Considerations:

* **Input Sanitization:**  More robust input sanitization is needed across all API endpoints to prevent XSS and other injection attacks.  Even with parameterized queries, client-side validation and sanitization are crucial.
* **CSV Import Security:**  The CSV import functionality could benefit from more extensive validation to prevent malicious code execution through malformed CSV files.  Currently, only a basic header check is in place.
* **Error Handling:** The error handling is partially implemented, but can be improved for better logging and less informative error responses to the client.
* **Rate Limiting:**  No rate limiting is implemented, potentially leaving the server vulnerable to brute-force attacks.
* **Authentication/Authorization:**  No authentication or authorization mechanisms are apparent in the provided code.  This is a critical security vulnerability.
* **File Handling:** While `path.join` is used, additional validation is needed to ensure that files are only accessed from safe locations and that filenames do not contain malicious characters.

## Recommendations:

* Implement comprehensive input validation and sanitization throughout the application.
* Add rate limiting to protect against brute-force attacks.
* Implement a robust authentication and authorization system (e.g., using JWT).
* Enhance error handling to provide better logging and less revealing error messages.
* Use a more secure method for file storage and access.
* Conduct thorough security testing (e.g., penetration testing) to identify and mitigate potential vulnerabilities.
* Consider using a more robust database system (like PostgreSQL) for better scalability and security features.

## Integration Patterns

The frontend interacts with the backend through AJAX calls to the API endpoints. Shared components are used consistently across the ticket and vulnerability pages.  Data flows primarily from the backend API to the frontend, where it's displayed using AG Grid and ApexCharts.

## Generated Documentation Files

The documentation generation would create the following markdown files, which would then be converted to HTML using a separate process:

* `overview.md`
* `api-tickets.md`
* `api-vulnerabilities.md`
* `frameworks-tabler.md`
* `frameworks-bootstrap.md`
* `frameworks-apexcharts.md`
* `frameworks-aggrid.md`
* `functions-overview.md`
* `functions-tickets.md`
* `database-schema.md`
* `ui-api-flowcharts.md`
* `page-flow-navigation.md`
* `bugs-found.md`
* `handoff-template.md`
* `javascript.md`
* `symbols.md`
* `docs-system.md`

## Analysis Summary

This analysis has identified the major components of the HexTrackr system, including its API endpoints, frontend functions, database schema, and some security aspects.  Significant security improvements are recommended.  The documentation structure is designed for automated generation using a code analysis tool that can parse the code and generate the markdown files based on the provided standards.

## Generated Files (Example - not actually generated here)

(This section would list the actual generated markdown files after the code analysis and documentation generation process is completed)

* `overview.md`
* `api/tickets.md`
* `api/vulnerabilities.md`
* ...

## Security Notes

The security assessment highlights several crucial vulnerabilities requiring immediate attention.  The recommendations above should be prioritized to ensure the security and stability of the system.

## Next Steps

1. **Automated Documentation Generation:** Develop a tool to automatically generate the documentation based on the provided codebase and markdown templates.
2. **Security Remediation:** Address the security concerns identified in the assessment, prioritizing authentication/authorization, input sanitization, and error handling.
3. **Frontend Migration:** Migrate the remaining JavaScript code from `vulnerabilities.html` to `vulnerabilities.js`, ensuring proper modularity and documentation.
4. **Testing:** Perform thorough unit, integration, and end-to-end testing to validate functionality and security.
5. **Deployment:**  Prepare the system for deployment, considering appropriate hosting and security measures.

This response provides a comprehensive analysis of the provided codebase and generates a structured plan for creating robust and secure documentation.  Remember that the actual markdown files would be produced by the automated documentation tool.  This is a high-level analysis, detailed documentation will require a dedicated code analysis and documentation generation process.
