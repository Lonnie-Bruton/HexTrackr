<!-- Fragment template for documentation content injected by docs-tabler.js -->
<section class="doc-fragment">
    <h1>Vulnerability Rollover Architecture</h1>
<p>HexTrackr employs a sophisticated &quot;rollover&quot; mechanism to process daily vulnerability scans. This architecture is designed to provide both a current, deduplicated view of all active vulnerabilities and a complete historical record for trend analysis.</p>
<p>This system is crucial for understanding the vulnerability landscape over time, such as tracking the lifecycle of a specific vulnerability or analyzing the effectiveness of remediation efforts.</p>
<h2>Core Concepts</h2>
<ol>
<li><strong>Daily Snapshots</strong>: Each CSV import is treated as a snapshot of the environment on a specific <code>scan_date</code>.</li>
<li><strong>Current State View</strong>: The system maintains a table (<code>vulnerabilities_current</code>) that always reflects the most up-to-date state of all known vulnerabilities.</li>
<li><strong>Historical Log</strong>: Another table (<code>vulnerability_snapshots</code>) keeps an immutable, append-only log of every vulnerability from every scan.</li>
<li><strong>Deduplication</strong>: A <code>unique_key</code> is generated for each vulnerability to accurately identify and track it across different scans.</li>
</ol>
<h2>The Rollover Process</h2>
<p>The process is triggered every time a new vulnerability CSV is imported with a specific <code>scan_date</code>. Hereâ€™s how it works:</p>
<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant API as server.js
    participant DB as SQLite

    User-&gt;&gt;API: POST /api/vulnerabilities/import (Uploads CSV with scan_date)
    API-&gt;&gt;DB: 1. Mark existing vulnerabilities as potentially stale
    Note right of DB: UPDATE vulnerabilities_current SET last_seen = scan_date WHERE scan_date &lt; new_scan_date

    loop For each row in new CSV
        API-&gt;&gt;API: 2. Generate unique_key for the vulnerability
        API-&gt;&gt;DB: 3. Insert into vulnerability_snapshots (historical log)
        API-&gt;&gt;DB: 4. UPSERT into vulnerabilities_current (current state)
        Note right of DB: - If unique_key exists, UPDATE last_seen and other fields.
        Note right of DB: - If unique_key is new, INSERT new record.
    end

    API-&gt;&gt;DB: 5. Remove stale vulnerabilities
    Note right of DB: DELETE FROM vulnerabilities_current WHERE last_seen &lt; new_scan_date

    API-&gt;&gt;DB: 6. Calculate and store daily totals
    Note right of DB: INSERT OR REPLACE INTO vulnerability_daily_totals

    API--&gt;&gt;User: Success response with import statistics
</code></pre>
<h3>Step-by-Step Explanation</h3>
<ol>
<li><p><strong>Mark as Stale (Precautionary)</strong>: Before processing the new scan, the system assumes all existing vulnerabilities in the <code>vulnerabilities_current</code> table might be stale. It updates their <code>last_seen</code> date to their previous <code>scan_date</code>.</p>
</li>
<li><p><strong>Generate Unique Key</strong>: For each vulnerability in the new CSV, a unique key is generated. The logic is:</p>
<ul>
<li>If a CVE exists: <code>normalize(hostname)|CVE</code></li>
<li>If no CVE: <code>normalize(hostname)|plugin_id|description</code></li>
</ul>
<p> This ensures that the same vulnerability on the same host is treated as a single entity, even if other attributes change.</p>
</li>
<li><p><strong>Log to Snapshots</strong>: The raw vulnerability record is always saved to the <code>vulnerability_snapshots</code> table. This creates the permanent historical record.</p>
</li>
<li><p><strong>Update Current State (UPSERT)</strong>: The system then checks the <code>vulnerabilities_current</code> table for the <code>unique_key</code>.</p>
<ul>
<li><strong>If it exists</strong>: The existing record is <strong>updated</strong>. Its <code>last_seen</code> date is set to the new <code>scan_date</code>, indicating it is still active. Other details like <code>vpr_score</code> are also updated.</li>
<li><strong>If it&#39;s new</strong>: A new record is <strong>inserted</strong> into <code>vulnerabilities_current</code>.</li>
</ul>
</li>
<li><p><strong>Remove Stale Vulnerabilities</strong>: After processing all rows from the new scan, any vulnerability in <code>vulnerabilities_current</code> whose <code>last_seen</code> date is still older than the new <code>scan_date</code> is considered resolved or no longer present. These records are deleted from the <code>vulnerabilities_current</code> table, but they remain in the <code>vulnerability_snapshots</code> table for historical purposes.</p>
</li>
<li><p><strong>Aggregate Daily Totals</strong>: Finally, the system recalculates the total counts and VPR scores for each severity for the new <code>scan_date</code> and stores them in the <code>vulnerability_daily_totals</code> table. This table powers the fast-loading dashboard charts.</p>
</li>
</ol>
<h2>Benefits of this Architecture</h2>
<ul>
<li><strong>Efficiency</strong>: The dashboard and API can query the small, indexed <code>vulnerabilities_current</code> and <code>vulnerability_daily_totals</code> tables for fast performance.</li>
<li><strong>Accurate Trending</strong>: The <code>vulnerability_snapshots</code> table provides a rich dataset for analyzing trends over time without being cluttered by the current state.</li>
<li><strong>Resilience</strong>: The append-only nature of the snapshots table makes the system resilient to data import errors.</li>
<li><strong>State Management</strong>: Automatically handles the lifecycle of vulnerabilities (new, active, resolved) without manual intervention.</li>
</ul>

    <!-- Note: This file is intentionally minimal. The full page scaffold, header, footer, and scripts
             are provided by docs-html/index.html. Content generated using this template will be
             fetched and injected into #content-container by docs-html/js/docs-portal-v2.js. -->
</section>
